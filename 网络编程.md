## 网络编程

### 1、tcp/ip 和 osi 

https://static001.geekbang.org/resource/image/cb/b4/cb34e0e3b7769498ea703fe6231201b4.png

![img](https://static001.geekbang.org/resource/image/cb/b4/cb34e0e3b7769498ea703fe6231201b4.png)

### 2、客户端-服务器网络模型

![img](https://static001.geekbang.org/resource/image/78/83/78e415180d2946c418485d30f3f78f83.png?wh=1266*228)

**ip和端口**

 IP用来表示网络世界的地址。同一台计算机ip是唯一的但每个应用的端口号是不同的。

> 端口号是16位整数最大为65536

当一个客户端发起连接请求时，客户端的端口是由操作系统内核临时分配的，称为临时端口；然而，前面也提到过，服务器端的端口通常是一个众所周知的端口。

>服务器的端口是一个总所皆知的端口，而客户端的是一个是那个应用一个端口

一个连接可由一个四元组确定 源ip 源端口 目标ip 目标端口

>（clientaddr:clientport, serveraddr: serverport)



客户端 - 服务器之间的连接

![img](https://static001.geekbang.org/resource/image/54/2a/543b5488f9422558069df507cfaa462a.png?wh=1004*328)



ip  192.168.0.1   32位 四字节   

其中前三字节是子网   最后一字节是主机地址 子网掩码只会由一连串的1和0组成

>新的表示法 192.168.0.12/30  即该子网掩码有30个1 两个0 有四个主机地址  ！！实际可用主机地址应该减去全1的广播地址和全0的不可用地址

网络地址=IP地址与子网掩码位与运算

192.168.0.1 & 255.255.255.0 就是其网络地址 192.168.0

！！备注：要去看ip地址分类内容

**全球域名系统 **(DNS)

电话簿记录了好友和电话的对应关系一样，域名（DNS）也记录了网站和 IP 的对应关系。

实际应用HTTP、HTTPS请求

**传输层协议TCP 和UDP**

tcp/ip 协议（传输控制协议） 不是具体的一个协议是一个协议簇

**socket本身并不是协议，它是应用层与TCP/IP协议族通信的中间软件抽象层，是一组调用接口（TCP/IP网络的API函数）**

TCP，又被叫做字节流套接字（Stream Socket）

>Stream sockets 是可靠的、双向连接的通讯串流。比如以“1-2-3”的顺序将字节流输出到套接字上，它们在另一端一定会以“1-2-3”的顺序抵达，而且不会出错。

其中的问题：tcp如何保证可靠性

>TCP 通过诸如连接管理，拥塞控制，数据流与窗口管理，超时和重传等一系列精巧而详细的设计，提供了高质量的端到端的通信方式。

UDP  数据报套接字（Datagram Socket）

UDP 在很多场景也得到了极大的应用，比如多人联网游戏、视频会议，甚至聊天

### 3、了解socket套接字和地址

<img src="https://static001.geekbang.org/resource/image/0b/64/0ba3f3d04b1466262c02d6f24ee76a64.jpg" alt="img" style="zoom: 25%;" />

！备注：要去剖析服务器执行过程的几个函数所做的操作。

建立连接之后客户端进程向<u>操作系统内核</u>发起 write 字节流写操作，内核协议栈将字节流通过网络设备传输到服务器端，服务器端从内核得到信息，将字节流从内核读入到进程中，并开始业务逻辑的处理，完成之后，服务器端再将得到的结果以同样的方式写给客户端。可以看到

**socket 是我们用来建立连接，传输数据的唯一途径。**

**通用套接字地址格式**

sockaddr 是一个通用的地址结构，通用的意思是适用于多种地址族

```socket

/* POSIX.1g 规范规定了地址族为2字节的值.  */
typedef unsigned short int sa_family_t;
/* 描述通用套接字地址  */
struct sockaddr{
    sa_family_t sa_family;  /* 地址族.  16-bit*/
    char sa_data[14];   /* 具体的地址值 112-bit */
  }; 
  sa_family 一般来说， IPV4使用“AF_INET”。
  sa_data 包含了一些远程电脑的地址、端口和套接字的数目，它里面的数据是杂溶在一起的
```

> sa_family   地址族表示以什么形式对地址进行解释和保存
>
> AF_LOCAL：表示的是本地地址，对应的是 Unix 套接字，这种情况一般用于本地 socket 通信，很多情况下也可以写成 AF_UNIX、AF_FILE；
>
> AF_INET：因特网使用的 IPv4 地址；
>
> AF_INET6：因特网使用的 IPv6 地址。

**IPv4 套接字格式地址**

``` 

/* IPV4套接字地址，32bit值.  */
typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };
  
/* 描述IPV4的套接字地址格式  */
struct sockaddr_in
  {
    sa_family_t sin_family; /* 16-bit */
    in_port_t sin_port;     /* 端口号  16-bit  65535*/ 
    struct in_addr sin_addr;    /* Internet address. 32-bit */


    /* 这里仅仅用作占位符，不做实际用处  */
    unsigned char sin_zero[8];
  };
```

已经被对应服务广为使用的端口，比如 ftp 的 21 端口，ssh 的 22 端口，http 的 80 端口等。一般而言，大于 5000 的端口可以作为我们自己应用程序的端口使用。

**IPv6 套接字地址格式**

>struct sockaddr_in6
>  {
>    sa_family_t sin6_family; /* 16-bit */
>    in_port_t sin6_port;  /* 传输端口号 # 16-bit */
>    uint32_t sin6_flowinfo; /* IPv6流控信息 32-bit*/
>    struct in6_addr sin6_addr;  /* IPv6地址128-bit */
>    uint32_t sin6_scope_id; /* IPv6域ID 32-bit */
>  };

整个结构体长度是 28 个字节，关键的地址从 32 位升级到 128 位

**几种套接字地址格式比较**

![image-20220116142529036](C:\Users\32886\AppData\Roaming\Typora\typora-user-images\image-20220116142529036.png)

### 4、套接字实现过程（包括三次握手的实际过程）

默认阻塞打开  可以用fcntl来改变为阻塞式打开

udp也可以调用connect 可以使得应用程序能够接收异步错误信息和提高性能

#### 服务器代码

```
服务器 操作
//创建socket (选协议族 ipv4之类 选择套接字类型 tcp或者udp)
int socket(int family, int type, int protocol); 
参数说明：
family：协议族 
    AF_INET：IPv4协议
    AF_INET6：IPv6协议
    AF_LOCAL：unix域协议
    AF_ROUTE：路由套接字
    AF_KEY：密钥套接字	
type：套接字类型
    SOCK_STREAM：字节流套接字 
    SOCK_DGRAM：数据报套接字 
    SOCK_RAW：原始套接字 
protocol：
    0（原始套接字除外）原本是用来指定通信协议的，但现在基本废弃
返回值：
	成功：非负套接字描述符
	失败： -1
    
//绑定 bind
int bind(int sockfd,struct sockaddr*my_addr,int addrlen);
参数说明： 
sockfd： 套接字描述符 
typmy_addre： 本地地址 
addrlen： 地址长度
我们需要注意到 bind 函数后面的第二个参数是通用地址格式sockaddr * addr。这里有一个地方值得注意，那就是虽然接收的是通用地址格式，实际上传入的参数可能是 IPv4、IPv6 或者本地套接字格式。bind 函数会根据 len 字段判断传入的参数 addr 该怎么解析，len 字段表示的就是传入的地址长度，它是一个可变值。
返回值：
	成功：0
	失败：-1
	
int listen(int sockfd,int backlog); 
参数说明：
sockfd： 
套接字描述符 
backlog： 
请求队列中允许的最大请求数，大多数系统缺省值为20
通过 listen 函数，可以将原来的"主动"套接字转换为"被动"套接字，告诉操作系统内核：“我这个套接字是用来等待用户请求的。”当然，操作系统内核会为此做好接收用户请求的一切准备，比如完成连接队列。
返回值：
	成功：0
	失败：-1
	
int accept(int sockfd,struct sockaddr*my_addr,int *addrlen); 
参数说明：
sockfd： 套接字描述符 
my_addr： 客户端地址 
addrlen： 地址长度
参数使用的是监听套接字是为成千上万客户服务的，而函数返回值的已连接套接字是用来和客户进行通信处理的
返回值：
	成功：全新的socket号
	失败：-1
```

#### 客户端代码

```
//创建socket (选协议族 ipv4之类 选择套接字类型 tcp或者udp)
int socket(int family, int type, int protocol); 
参数说明：
family：协议族 
    AF_INET：IPv4协议
    AF_INET6：IPv6协议
    AF_LOCAL：unix域协议
    AF_ROUTE：路由套接字
    AF_KEY：密钥套接字	
type：套接字类型
    SOCK_STREAM：字节流套接字 
    SOCK_DGRAM：数据报套接字 
    SOCK_RAW：原始套接字 
protocol：
    0（原始套接字除外）原本是用来指定通信协议的，但现在基本废弃
//连接
int connect(int sockfd,struct sockaddr*serv_addr,int addrlen); 
参数说明：
sockfd： 套接字描述符
serv_addr： 服务器端地址 
addrlen： 地址长度
客户在调用函数 connect 前不必非得调用 bind 函数，因为如果需要的话，内核会确定源 IP 地址，并按照一定的算法选择一个临时端口作为源端口。
返回值：
	成功：0
	失败：-1
```

> connect 中三个常见的错误返回
>
> 如果是 TCP 套接字，那么调用 connect 函数将激发 TCP 的三次握手过程，而且仅在连接建立成功或出错时才返回。其中出错返回可能有以下几种情况：
>
> 三次握手无法建立，客户端发出的 SYN 包没有任何响应，于是返回 TIMEOUT 错误。这种情况比较常见的原因是对应的服务端 IP 写错。
>
> 客户端收到了 RST（复位）回答，这时候客户端会立即返回CONNECTION REFUSED 错误。这种情况比较常见于客户端发送连接请求时的请求端口写错，因为 RST 是 TCP 在发生错误时发送的一种 TCP 分节。产生 RST 的三个条件是：目的地为某端口的 SYN 到达，然而该端口上没有正在监听的服务器（如前所述）；TCP 想取消一个已有连接；TCP 接收到一个根本不存在的连接上的分节。
>
> 客户发出的 SYN 包在网络上引起了"destination unreachable"，即目的不可达的错误。这种情况比较常见的原因是客户端和服务器端路由不通。根据不同的返回值，我们可以做进一步的排查。

#### TCP 三次握手:

![img](https://static001.geekbang.org/resource/image/65/29/65cef2c44480910871a0b66cac1d5529.png)

TCP 三次握手的解读我们先看一下最初的过程，服务器端通过 socket，bind 和 listen 完成了被动套接字的准备工作，被动的意思就是等着别人来连接，然后调用 accept，就会阻塞在这里，等待客户端的连接来临；客户端通过调用 socket 和 connect 函数之后，也会阻塞。接下来的事情是由操作系统内核完成的，更具体一点的说，是操作系统内核网络协议栈在工作。

下面是具体的过程：

1.客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 j，客户端进入 SYNC_SENT 状态；

2：服务器端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 j+1，表示对 SYN 包 j 的确认，同时服务器也发送一个 SYN 包，告诉客户端当前我的发送序列号为 k，服务器端进入 SYNC_RCVD 状态；

3.客户端协议栈收到 ACK 之后，使得应用程序从 connect 调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务器端的 SYN 包进行应答，应答数据为 k+1；应答包到达服务器端后，服务器端协议栈使得 accept 阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入 ESTABLISHED 状态。

### 5、套接字读写

#### 一、发送数据

**write、send、sendmsg**

```
ssize_t write (int socketfd, const void *buffer, size_t size)
ssize_t send (int socketfd, const void *buffer, size_t size, int flags)
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags)
```

普通文件描述符和套接字描述符看着表现形式一样，内在形式区别还是有的

对于普通文件描述符而言，一个文件描述符代表了打开的一个文件句柄，通过调用 write 函数，操作系统内核帮我们不断地往文件系统中写入字节流。注意，写入的字节流大小通常和输入参数 size 的值是相同的，否则表示出错。

对于套接字描述符而言，它代表了一个双向连接，在套接字描述符上调用 write 写入的字节数有可能比请求的数量少，这在普通文件描述符情况下是不正常的。

**发送缓冲区**

你一定要建立一个概念，当 TCP 三次握手成功，TCP 连接成功建立后，操作系统内核会为每一个连接创建配套的基础设施，比如发送缓冲区。

> 缓冲区的作用 ：高速设备与低速设备的不匹配，势必会让高速设备花时间等待低速设备，我们可以在这两者之间设立一个缓冲区

发送缓冲区的大小可以通过套接字选项来改变，当我们的应用程序调用 write 函数时，实际所做的事情是把数据从应用程序中拷贝到操作系统内核的发送缓冲区中，并不一定是把数据通过套接字写出去。

>可用setsockopt SO_RCVBUF和SO_SNDBUF修改缓冲区大小

https://www.jianshu.com/p/3be7582ddf78

write 会在什么时候返回？

大部分unix系统会一直等到应用程序数据完全放到操作系统内核的发送缓冲区中函数就会返回（数据并没有全部被发送出去），这部分数据会在稍后由操作系统内核通过网络发送出去

>当 TCP 连接建立之后，它就开始运作起来。你可以把发送缓冲区想象成一条包裹流水线，有个聪明且忙碌的工人不断地从流水线上取出包裹（数据），这个工人会按照 TCP/IP 的语义，将取出的包裹（数据）封装成 TCP 的 MSS 包，以及 IP 的 MTU 包，最后走数据链路层将数据发送出去。这样我们的发送缓冲区就又空了一部分，于是又可以继续从应用程序搬一部分数据到发送缓冲区里，这样一直进行下去，到某一个时刻，应用程序的数据可以完全放置到发送缓冲区里。在这个时候，write 阻塞调用返回。注意返回的时刻，应用程序数据并没有全部被发送出去，发送缓冲区里还有部分数据，这部分数据会在稍后由操作系统内核通过网络发送出去。

#### 二、读取数据

 ```

ssize_t read (int socketfd, void *buffer, size_t size);
int recv(int sockfd,void *buf,int len,unsigned int flags);
 ```

函数要求操作系统内核从套接字描述字 socketfd读取最多多少个字节（size），并将结果存储到 buffer 中。返回值告诉我们实际读取的字节数目.

如果返回值为 0，表示 EOF（end-of-file），这在网络中表示对端发送了 FIN 包，要处理断连的情况；

！！如果是想让应用程序每次偶读读到size个字节 是可以操作的

**要注意的两点！！**

对于 send 来说，返回成功仅仅表示数据写到发送缓冲区成功，并不表示对端已经成功收到。

对于 read 来说，需要循环读取数据，并且需要考虑 EOF 等异常条件。

#### 三、(四次挥手)套接字关闭

![f34823ce42a49e4eadaf642a75d14de1](E:\WORK\code\Internet\photo\f34823ce42a49e4eadaf642a75d14de1.png)

首先，一方应用程序调用 close，我们称该方为主动关闭方，该端的 TCP 发送一个 FIN 包，表示需要关闭连接。之后主动关闭方进入 FIN_WAIT_1 状态。接着，接收到这个 FIN 包的对端执行被动关闭。这个 FIN 由 TCP 协议栈处理，我们知道，TCP 协议栈为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，应用程序可以通过 read 调用来感知这个 FIN 包。一定要注意，这个 EOF 会被放在已排队等候的其他已接收的数据之后，这就意味着接收端应用程序需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，被动关闭方进入 CLOSE_WAIT 状态。接下来，被动关闭方将读到这个 EOF，于是，应用程序也调用 close 关闭它的套接字，这导致它的 TCP 也发送一个 FIN 包。这样，被动关闭方将进入 LAST_ACK 状态。最终，主动关闭方接收到对方的 FIN 包，并确认这个 FIN 包。主动关闭方进入 TIME_WAIT 状态，而接收到 ACK 的被动关闭方则进入 CLOSED 状态。经过 2MSL 时间之后，主动关闭方也进入 CLOSED 状态。Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒。

>**最大分组 MSL**
>
>MSL 是任何 IP 数据报能够在因特网中存活的最长时间

>time_wait 的作用
>
>1.为了确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭
>
>2.为了能够接收 主机 1 的 ACK 报文没有传输成功，那么主机 2 就会重新发送 FIN 报文。

```
int on = 1; 
setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
//在bind之前设置SO_REUSEADDR以便服务端程序可以在极短时间内复用同 一个端口启动。
```



### 6、连接的可靠性

1.Keep-Alive心跳包机制

定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。

#### 可靠性的机制

 https://www.jianshu.com/p/42dbcd39c3e7

确认应答、超时重传（RTT）、拥塞控制、流量控制、连接管理

##### 1.确认应答（ack）机制

TCP将每个字节的数据都进行了编号，即为序列号。确认序号=序号+1

##### 2.超时重传机制

两种情况

1、如果主机A发送给主机B的报文，主机B在规定的时间内没有及时收到主机A发送的报文，发送包丢失，这时就需要触发超时重传机制。

2.如果主机A未收到B发来的确认应答，ACK丢了。因此主机B会收到很多重复的数据，那么，TCP协议需要能够识别出那些包是重复的包，并且把重复的包丢弃，这时候我们可以用前面提到的序列号，很容易做到去重的效果

>超时重传时间的确认
>超时重传的时间设置的太短，会引起很多报文的不必要重传；
>时间设置的过长，又会使网络的空闲时间增大，降低传输效率；TCP采用了一种自适应算法，它记录一个报文发出的时间，以及收到相应确认的时间，者两个时间之差就是报文的往返时间RTT；最理想的情况下，找到一个最小的时间，保证确认应答一定能在这个时间内返回Linux中，超时以500s为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍；如果重发一次仍然得不到应答，等待2*500ms后再进行重传；如果仍然得不到应答，等待4*500ms进行重传，依次类推，以指数形式递增;累积到一定的重传次数，TCP认为网络或者对端主机出现异常，强制关闭连接。

##### 3.连接管理

连接管理机制即TCP建立连接时的三次握手和断开连接时的四次挥手。

##### 4.流量控制

接收端处理数据的速度是有限的，如果发送方发送数据的速度过快，导致接收端的缓冲区满，而发送方继续发送，就会造成丢包，继而引起丢包重传等一系列连锁反应。因此TCP支持根据接收端的处理能力，来决定发送端的发送速度，这个机制叫做流量控制。

**在TCP报文段首部中有一个16位窗口长度，接收方在应答包上将自身缓冲区剩余量放到窗口大小中，如果缓冲区满就将窗口置0，发送方收到后就不再发送数据，但是要定期发送窗口探测数据段使接收方把窗口告诉发送端**

**！！高端处理滑动窗口**

>

##### 5.拥塞控制

主要是防止网络过于堵塞，容易丢包

流量控制解决了两台主机之间因传送速率而可能引起的丢包问题，在一方面保证了TCP数据传送的可靠性。然而如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。

为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。
 此处引入一个拥塞窗口：
 发送开始时定义拥塞窗口大小为1；每次收到一个ACK应答，拥塞窗口加1；而在每次发送数据时，发送窗口取拥塞窗口与接送段接收窗口最小者。
 慢启动：在启动初期以指数增长方式增长；设置一个慢启动的阈值，当以指数增长达到阈值时就停止指数增长，按照线性增长方式增加；线性增长达到网络拥塞时立即“乘法减小”，拥塞窗口置回1，进行新一轮的“慢启动”，同时新一轮的阈值变为原来的一半。

**拥塞控制，归根结底是TCP协议想尽可能快的把数据传输给对方，但又要避免给网络造成最大压力的最好方案。**

两个窗口一个发送方窗口一个接收方窗口，发送方根据接收方的窗口大小＋拥塞窗口大小动态的选择发送窗口大小，保证不超过接收窗口大小。

![Snipaste_2022-02-07_15-45-49](E:\WORK\code\Internet\photo\Snipaste_2022-02-07_15-45-49.png)

### 7、I/O多路复用

#### 一、先了解几种io模型

https://www.jianshu.com/p/486b0965c296

五种对io处理的模型

1.阻塞io模型

2.非阻塞模型

3.i/o多路转接模型

4.信号驱动io模型

5.异步io模型

#### 二、三种io复用模型 select pello epllo

##### 1.**select：**

**基本原理：**select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。

<img src="E:\WORK\code\Internet\photo\667911-20160426172125064-1263315531.png" alt="667911-20160426172125064-1263315531" style="zoom: 33%;" />

```

int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);
maxfd: 表示的是待测试的描述符基数，它的值是待测试的最大描述符加 1
读描述符集合 readset、写描述符集合 writeset 和异常描述符集合 exceptset
struct timeval { //结构体时间
  long   tv_sec; /* seconds */
  long   tv_usec; /* microseconds */
};
三种情况  
设置为0：一直阻塞
设置为非0：等待固定时间就返回或者直接返回
两个都设置为0：完全不等待直接返回
返回：若有就绪描述符则为其数目，若超时则为0，若出错则为-1
```

*四个关键的宏*

```
void FD_ZERO(fd_set *fdset);            //用来初始化集合　　　　　　
void FD_SET(int fd, fd_set *fdset);　　  //用来把对应套接字 fd 的元素置1；
void FD_CLR(int fd, fd_set *fdset);　　　//用来把对应套接字 fd 的元素清0；
int  FD_ISSET(int fd, fd_set *fdset);   //用来检测对应套接字 fd的是否为1
```

！select 调用每次完成测试之后，内核都会修改描述符集合，通过修改完的描述符集合来和应用程序交互，应用程序使用 FD_ISSET 来对每个描述符进行判断，从而知道什么样的事件发生

>**描述符基数是当前最大描述符 +1；每次 select 调用完成之后，记得要重置待测试集合。**
>
>select 优点：几乎所有平台都有实现，跨平台支持
>
>缺点：
>
>​    1.单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024
>
>​	2.对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。
>
>​	3.需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。
>
>

##### 2.**poll**

**基本原理：**`poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间`，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。

```

int poll(struct pollfd *fds, unsigned long nfds, int timeout); 
结构体数组
struct pollfd {
    int    fd;       /* 描述符 fd */
    short  events;   /* 描述符上待检测的事件类型 */
    short  revents;  /* 实际发生的 return events */
 };
 nfds：数组 fds 的大小
 timeout：<0 阻塞 =0 直接返回 >0 等待指定毫秒数返回
返回值：若有就绪描述符则为其数目，若超时则为0，若出错则为-1
```

过程

>应用进程调用了poll之后，会把poll_fd从用户空间拷贝到内核空间，随后应用进程进入阻塞；
>内核根据poll_fd的fd得到需要处理的描述符，根据描述符是否准备好数据，给poll_fd的revents进行置位；
>进程被唤醒，拿到内核处理过后的poll_fd，就可以通过与操作判断到对应的事件是否被置位，从而知道套接字数据是否已经准备好了。

优点：与select类似，非阻塞IO直接轮训查询数据是否准备好，每次查询都要切换内核态，轮训消耗CPU，而poll则是把查询多个描述符的动作交给了内核，避免了CPU消耗和减少了内核态的切换。

这里引入了poll_fd结构体，内核只是修改poll_fd结构体中的revents，这样每次读取数据的时候，重置revents，就可以复用poll_fd了，不用像select那样反复初始化一个新的rset。

缺点：

- 每次调用poll都需要拷贝新的poll_fd到内核空间，这里会做一个用户态到内核态的切换；

- 拿到poll_fd的结果后，应用进程需要遍历整个poll_fd，才知道哪些文件描述符有数据可以处理。

  

![6e7a467bc6f5985eebbd94ef7de14aaa](E:\WORK\code\Internet\photo\6e7a467bc6f5985eebbd94ef7de14aaa.webp)

常用非堵塞io和io多路复用一起配合使用

`poll还有一个特点是“水平触发”`，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。

##### 3.epoll

https://www.cnblogs.com/Hijack-you/p/13057792.html（介绍流程）

https://blog.csdn.net/daaikuaichuan/article/details/83862311（介绍epoll机制的核心）

LT水平触发：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，`应用程序可以不立即处理该事件`。下次调用epoll_wait时，会再次响应应用程序并通知此事件

ET边沿触发：高速模式只支持非阻塞下

**基本原理：**`epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次`。还有一个特点是，`epoll使用“事件”的就绪通知方式`，通过epoll_ctl注册fd，`一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd`，epoll_wait便可以收到通知。

**epoll_create**

```
int epoll_create(int size);//建了epoll 实例
int epoll_create1(int flags);
size内核期望监控的文件描述字大小(现在不需要了设置为大于0就行了)
        返回值: 若成功返回一个大于0的值，表示epoll实例；若返回-1表示出错
```

**epoll_ctl**

~~~
 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);//往这个 epoll 实例增加或删除监控的事件
 epfd: 是刚刚调用 epoll_create 创建的 epoll 实例描述字
 op: 第二个参数表示增加还是删除一个监控事件，它有三个选项可供选择：EPOLL_CTL_ADD： 向 epoll 实例注册文件描述符对应的事件；
EPOLL_CTL_DEL：向 epoll 实例删除文件描述符对应的事件；
EPOLL_CTL_MOD： 修改文件描述符对应的事件。
fd: 第三个参数是注册的事件的文件描述符，比如一个监听套接字。
*event: 表示的是注册的事件类型
struct epoll_event {
     uint32_t     events;      /* 二进制事件类型可读可写还有设置触发方式等 */
     epoll_data_t data;        /* 这里常用fd */
 };
typedef union epoll_data {
     void        *ptr;
     int          fd;
     uint32_t     u32;
     uint64_t     u64;
 } epoll_data_t;
        返回值: 若成功返回0；若返回-1表示出错
~~~

**epoll_wait**

~~~
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
	epfd:epoll 实例描述字
	events:需要处理的 I/O 事件，这是一个数组这个数组的每个元素都是一个需要待处理的 I/O 事件.
	maxevents:第三个参数是一个大于 0 的整数，表示 epoll_wait 可以返回的最大事件值。
	timeot:第四个参数是 epoll_wait 阻塞调用的超时值，如果这个值设置为 -1，表示不超时；如果设置为 0 则立即返回，即使没有任何 I/O 事件发生
  返回值: 成功返回的是一个大于0的数，表示事件的个数；返回0表示的是超时时间到；若出错返回-1.
~~~

**epoll的优点：**

`1、没有最大并发连接的限制`，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。

`2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降`。

　　只有活跃可用的FD才会调用callback函数；`即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关`，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。

`3、内存拷贝`，利用mmap()文件映射内存加速与内核空间的消息传递；`即epoll使用mmap减少复制开销`。利用共享内存实现，不用多次进行文件拷贝

 ### 8、扩展http

https://www.cnblogs.com/an-wen/p/11180076.html

https://blog.csdn.net/u010710458/article/details/79636625

#### 1.http协议

HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）

>\1. 客户端连接到Web服务器
>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，[http://www.baidu.com](http://www.baidu.com/)。
>
>\2. 发送HTTP请求
>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。
>
>\3. 服务器接受请求并返回HTTP响应
>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。
>
>\4. 释放连接TCP连接
>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;
>
>\5. 客户端浏览器解析HTML内容
>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

1. 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;
2. 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;
3. 浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;
4. 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
5. 释放 TCP连接;
6. 浏览器将该 html 文本并显示内容; 　

#### 2.http报文

请求行、请求首部、空行、请求数据

相应行、相应首部、空行、响应数据

请求报文：



响应报文：


